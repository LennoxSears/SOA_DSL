//***********************************************************************************
//*  NXP SOA-check monitor                                                          *
//***********************************************************************************
//
// Filename:           ovcheck_pwl.va
// Version:            1.0.0
// Date:               2023-09-08
// Author(s):          Gert-Jan Smit
// Source:
//   - git repository: soacheck_va
//   - git commit:     54229bcf1d93256c0ec293b291f2e92edb45a9c6
//
// Description:
// This monitor is intended to enable over-voltage checks with voltage-dependent
// boundaries having a piece-wise-linear dependence. The check is one-sided
// (upper bound only). Checking for a lower limit can be achieved by reversing
// the input voltage connections.
//
// Known limitations:
// - This code requires mica version 16.1 or higher.
//
//***********************************************************************************

`include "disciplines.h"

`define NMAX 5
`define LARGE_NUMBER 1e10

// general condition that must be satisfied to do any monitoring at all
// set to 1 if not needed
`define do_monitor ((vlim1 != 0.0) || (vc1 != 0.0))

// calculated value of main quantity to be monitored
// also include other variables that must be updated at each iteration
`define get_main_quantity qval = V(p, n);

// function call to oor_condition()
`define call_oor_condition oor_condition(qval, limit)

// Below are all possible output messages. The format string and variable list are in separate macros.
// (using macros, because string-variables are not recognized as format-strings in $write() statement)

// macro definitions for warning messages (shared)

`define label_fatal   "\n    [SOACHECK_FATAL] "
`define label_tr      "\n    [SOACHECK_TR] "
`define label_info    "\n    [SOACHECK_INFO] "
`define label_dc      "\n    [SOACHECK_DC] "
`define label_dc_end  "\n    [SOACHECK_DC_END] "
`define label_debug   "\n    [SOACHECK_DEBUG] "

`define key_instance      "instance: %m"
`define key_rule          "rule: \"%s\""
`define key_branch        "branch: \"%s\""
`define key_boundary      "boundary: \"[%.5g, %.5g]\""
`define key_boundary_on   "boundary_on: \"[%.5g, %.5g]\""
`define key_boundary_off  "boundary_off: \"[%.5g, %.5g]\""
`define key_device        "device: \"%s\""
`define key_exit_value    "exit value: %.5g"
`define key_exit_time     "exit time: %.15g"
`define key_entry_value   "entry value: %.5g"
`define key_entry_time    "entry time: %.15g"
`define key_param         "parameter: \"%s\""
`define key_peak_value    "peak value: %.5g"
`define key_peak_time     "peak time: %.15g"
`define key_value         "value: %.5g"
`define key_duration      "duration: %.3g"
`define key_duration_perc "duration percentage: %.3g%%"
`define key_suppr_msg     "suppressed messages: %d"
`define key_severity      "severity: \"%s\""
`define key_oversh_perc   "overshoot percentage: %.3g%%"
`define key_message       "message: \"%s\""

// Debug message (printed when debug=1)
`define msg_debug \
    `label_debug, \
    `key_instance, ", ", \
    `key_device, device, "\n"

// physical constants
`define kbol 1.3806226e-23
`define qele 1.6021918e-19

// Message at first violation, when causing simulation to abort (only when stop==1)
`define msg_fatal \
    `label_fatal, \
    `key_instance, ", ", \
    `key_device, device, ", ", \
    `key_branch, branch1, ", ", \
    `key_exit_value, exit_value, ", ", \
    `key_message, msg, "\n"

// Message during transient, when returning to SOA
`define msg_tr \
    `label_tr, \
    `key_instance, ", ", \
    `key_branch, branch1, ", ", \
    `key_exit_value, exit_value, ", ", \
    `key_exit_time, exit_time, ", ", \
    `key_entry_value, entry_value, ", ", \
    `key_entry_time, entry_time, ", ", \
    `key_peak_value, this_peak_val, ", ", \
    `key_peak_time, this_peak_time, ", ", \
    `key_duration, dur, ", ", \
    `key_message, msg, "\n"

// Summary message (when within SOA at end of transient)
`define msg_info \
    `label_info, \
    `key_instance, ", ", \
    `key_device, device, ", ", \
    `key_branch, branch1, ", ", \
    `key_peak_value, tot_peak_val, ", ", \
    `key_peak_time, tot_peak_time, ", ", \
    `key_duration, dur_tot, ", ", \
    `key_duration_perc, 100 * frac, ", ", \
    `key_suppr_msg, num_suppressed_msg, ", ", \
    `key_severity, severity, ", ", \
    `key_message, msg, "\n"

// Summary message, with severity removed
`define msg_info_no_severity \
    `label_info, \
    `key_instance, ", ", \
    `key_device, device, ", ", \
    `key_branch, branch1, ", ", \
    `key_peak_value, tot_peak_val, ", ", \
    `key_peak_time, tot_peak_time, ", ", \
    `key_duration, dur_tot, ", ", \
    `key_duration_perc, 100 * frac, ", ", \
    `key_suppr_msg, num_suppressed_msg, ", ", \
    `key_message, msg, "\n"

// Message when leaving SOA during dc analysis
`define msg_dc_exit \
    `label_dc, \
    `key_instance, ", ", \
    `key_branch, branch1, ", ", \
    `key_exit_value, exit_value, ", ", \
    `key_message, msg, "\n"

// Message when returning to SOA during dc analysis
`define msg_dc_entry \
    `label_dc, \
    `key_instance, ", ", \
    `key_branch, branch1, ", ", \
    `key_exit_value, exit_value, ", ", \
    `key_entry_value, qval, ", ", \
    `key_peak_value, tot_peak_val, ", ", \
    `key_message, msg, "\n"

// Summary message at end of dc analysis
`define msg_dc_end \
    `label_dc_end, \
    `key_instance, ", ", \
    `key_branch, branch1, ", ", \
    `key_value, qval, ", ", \
    `key_exit_value, exit_value, ", ", \
    `key_peak_value, tot_peak_val, ", ", \
    `key_message, msg, "\n"


(* instrument_module *)
module ovcheckva_pwl(p, n, pc, nc);
    input p, n, pc, nc;
    electrical p, n, pc, nc;

    // Mandatory model parameters
    parameter integer level        = 1;     // General parameter for all simkit devices (not used)
    parameter integer paramchk     = 0;     // General parameter for all simkit devices used for level of clip warnings
    (* type="instance" *)
    parameter string  device       = "";    // Name of the device (or device model)
    parameter real    tmin         = 0.0;   // Minimal time outside of SOA before a warning is issued
    parameter real    tdelay       = 0.0;   // Time after start of transient that checking is activated
    parameter real    tmaxfrac     =-2.0;   // Maximum acceptable fraction of time outside of SOA
    parameter integer vballmsg     = 1;     // 0: only END/INFO messages; 1: TR message if peak is higher than before; 2: all TR messages
    parameter integer stop         = 0;     // Stop simulation on SOA violation when STOP==1
    parameter integer soadebug     = 0;     // If set to 1, print debug-message @initial_step

    parameter string  message1     = "";    // Optional informational message to be used in SOA messages

    // check-specific model parameters
    parameter string branch1    = "V(p,n)";   // Name of the branch to be used in SOA messages
    parameter real   vlim1       = 0.0;       // Voltage limit at 1st point
    parameter real   vc1         = 0.0;       // Control voltage value at 1st point
    parameter real   vlim2       = 0.0;       // Voltage limit at 2nd point
    parameter real   vc2         = 0.0;       // Control voltage value at 2nd point
    parameter real   vlim3       = 0.0;       // Voltage limit at 3rd point
    parameter real   vc3         = 0.0;       // Control voltage value at 3rd point
    parameter real   vlim4       = 0.0;       // Voltage limit at 4th point
    parameter real   vc4         = 0.0;       // Control voltage value at 4th point
    parameter real   vlim5       = 0.0;       // Voltage limit at 5th point
    parameter real   vc5         = 0.0;       // Control voltage value at 5th point
    (* type="instance" *)
    parameter integer dummy        = 0;       // just to make all other pars model-parameters

    // definition of out-of-range condition
    analog function integer oor_condition;
        input qval, limit;
        real qval, limit;
        begin
            oor_condition = (qval > limit);
        end
    endfunction

    // mandatory variables
    integer          outofrange, num_suppressed_msg;
    real             start_time, exit_time, entry_time, exit_value, entry_value, dur, total_time;
    real             this_peak_time, tot_peak_time, dur_oor;
    real             qval, this_peak_val, tot_peak_val;
    real             t_now;
    real             dur_tot, frac;
    string           msg, severity;

    // check-specific variables
    real             Vc, limit;
    integer          i;
    // interval 0 is [-inf,vc1], interval 1 is [vc1,vc2], ..., interval 4 is [vc4,inf]
    // vx[i] is the upper end of interval i
    real             slope[0:`NMAX], v0[0:`NMAX], vx[0:`NMAX];

    analog begin
        @(initial_step) begin : initial_block
            real vlim[1:`NMAX], vc[1:`NMAX];

            msg = message1;
            if (soadebug == 1) begin
                $write(`msg_debug);
            end

            // put input parameters in array, for easier processing
            vlim[1] = vlim1;
            vlim[2] = vlim2;
            vlim[3] = vlim3;
            vlim[4] = vlim4;
            vlim[5] = vlim5;
            vc[1] = vc1;
            vc[2] = vc2;
            vc[3] = vc3;
            vc[4] = vc4;
            vc[5] = vc5;

            // set slope, boundary, and cut-off for each interval
            slope[0] = 0.0; // first interval is constant value
            v0[0] = vlim[1];
            vx[0] = vc[1];
            for (i = 1; i <= (`NMAX - 1); i = i + 1) begin  // loop over all 'inner' intervals
                if ((vc[i + 1] == 0.0) && (vlim[i + 1] == 0.0)) begin
                    // this means that i was the last meaningful point
                    slope[i] = 0; // continue with constant value until end
                    v0[i] = vlim[i];
                    vx[i] = `LARGE_NUMBER; // automatically annihilates all subsequent points
                end else begin
                    if (vc[i + 1] > vc[i]) begin
                        // calculate slope and axis-crossing for line in this interval
                        slope[i] = (vlim[i + 1] - vlim[i]) / (vc[i + 1] - vc[i]);
                        v0[i] = vlim[i] - vc[i] * slope[i];
                        vx[i] = vc[i + 1];
                    end else begin
                        // this interval will never be used; but it allows for making a jump in value
                        slope[i] = 0.0;
                        v0[i] = 0.0;
                        vx[i] = vx[i - 1] - 1.0;
                    end // if
                end // if
            end // for-loop
            slope[`NMAX] = 0.0; // continue with constant value until end
            v0[`NMAX] = vlim[`NMAX];
            vx[`NMAX] = `LARGE_NUMBER; // 'endpoint' of last interval
        end

        @(initial_step("tran")) begin
            outofrange = 0;
            start_time = $abstime; // needed for situation when tran-analysis does not start at t=0.
            t_now = start_time;
            dur_oor = 0.0;
            tot_peak_val = 0.0;
        end

        @(initial_step("dc")) begin
            outofrange = 0;
            tot_peak_val = 0.0;
        end

        // get present values
        t_now = $abstime;
        `get_main_quantity // voltage to monitor
        Vc = V(pc, nc);  // control voltage

        if (`do_monitor && ((t_now >= (start_time + tdelay)) || analysis("dc"))) begin
            // calculate limit as function of control voltage
            limit = v0[`NMAX];
            for (i = 0; i <= `NMAX; i = i + 1) begin  // loop over all intervals
                if (Vc < vx[i]) begin
                    limit = v0[i] + slope[i] * Vc;
                    i = `NMAX + 1; // break out of loop
                end
            end
            case (outofrange)
                0 : begin // signal currently in range
                    if (`call_oor_condition == 1) begin // going out-of-range
                        outofrange = 1;  // set status to out-of-range
                        exit_time = t_now;
                        exit_value = qval;

                        // update peak value and time
                        this_peak_val = qval;
                        this_peak_time = t_now;
                        if (analysis("dc")) begin
                            if (stop >= 1) begin
                                $write(`msg_fatal);
                                $fatal(0, "\nFATAL: Simulation is terminated (STOP == 1).");
                            end
                            if (vballmsg >= 1) begin
                                $write(`msg_dc_exit);
                            end
                        end
                    end
                end
                1 : begin // signal currently out of range
                    if (qval > this_peak_val) begin // update peak value and time
                        this_peak_val = qval;
                        this_peak_time = t_now;
                    end
                    if (`call_oor_condition == 0) begin // getting back in range
                        outofrange = 0;
                        entry_time = t_now;
                        entry_value = qval;
                        dur = entry_time - exit_time;
                        if (dur > tmin) begin
                            if (stop >= 1) begin
                                $write(`msg_fatal);
                                $fatal(0, "\nFATAL: Simulation will be terminated (STOP == 1).");
                            end
                            if ((vballmsg >= 2) || ((vballmsg == 1) && (this_peak_val > tot_peak_val))) begin
                                $write(`msg_tr);
                            end else begin
                                num_suppressed_msg = num_suppressed_msg + 1;
                            end
                        end
                        dur_oor = dur_oor + dur; // event adds to total, even if shorter than tmin
                        if (this_peak_val > tot_peak_val) begin // update over-all peak value and time
                            tot_peak_val = this_peak_val;
                            tot_peak_time = this_peak_time;
                        end
                        if (analysis("dc")) begin
                            if (vballmsg >= 1) begin
                                $write(`msg_dc_entry);
                            end
                        end
                    end
                end
                default : ;// should never get here
            endcase // case (outofrange)
        end else begin  // (if $abstime >= tdelay)
            // keep track of status, even when not monitoring
            outofrange = `call_oor_condition;
            exit_time = t_now;
            exit_value = qval;
        end

        // Summaries at end of analysis
        @(final_step("tran")) begin
            total_time = t_now - start_time - tdelay;
            if (`do_monitor && ((dur_oor > 0.0) || (outofrange != 0))) begin
                if (outofrange == 1) begin
                    // handle ongoing violation
                    entry_time = t_now;
                    entry_value = qval;
                    dur = entry_time - exit_time;
                    if ((vballmsg >= 1) && (dur > tmin)) begin
                        $write(`msg_tr);
                    end
                    // update totals
                    dur_oor = dur_oor + dur;
                    if (this_peak_val > tot_peak_val) begin
                        tot_peak_val = this_peak_val;
                        tot_peak_time = this_peak_time;
                    end
                end
                dur_tot = dur_oor;
                frac = dur_tot / total_time;
                if (tmaxfrac < 0.0) begin
                    severity = "review";
                end else begin
                    if (frac < tmaxfrac) begin
                        severity = "low";
                    end else begin
                        severity = "high";
                    end
                end
                if (tmaxfrac >= -1.5) begin
                    $write(`msg_info);
                end else begin
                    $write(`msg_info_no_severity);
                end
            end // if do_monitor
        end // final_step tran
        @(final_step("dc")) begin
            if (`do_monitor && (this_peak_val > tot_peak_val)) begin // update over-all peak value
                tot_peak_val = this_peak_val;
            end
            if (`do_monitor && ((tot_peak_val != 0.0) || (outofrange != 0))) begin
                $write(`msg_dc_end);
            end
        end // final_step dc
    end // analog
endmodule // ovcheckva
