//***********************************************************************************
//*  NXP SOA-check monitor                                                          *
//***********************************************************************************
//
// Filename:           ovcheck_ldmos_hci_tddb.va
// Version:            1.0.0
// Date:               2023-09-08
// Author(s):          Gert-Jan Smit
// Source:
//   - git repository: soacheck_va
//   - git commit:     54229bcf1d93256c0ec293b291f2e92edb45a9c6
//
// Description:
// This module provides a (USP-compatible) monitor that checks for the HCI-TDDB
// breakdown mechanism in high-voltage devices. The criterion is based on the
// report "HCI-TDDB Flagging Tool for PLD45" by Maarten Swaanenberg (d.d. Sep-14
// 2018).
//
// Known limitations:
// - This code requires mica version 16.1 or higher.
// - Implementation for p-type devices only!
//
//***********************************************************************************

`include "disciplines.h"

// No warnings if abs(Vgs) is beyond this value (to avoid unnecessary computation and
// risk of numerical overflow).
`define Vgs_lim 15.0

// general condition that must be satisfied to do any monitoring at all
// set to 1 if not needed
`define do_monitor ((vds_wc < 0) && (vgs_wc < 0))

// calculated value of main quantity to be monitored
// also include other variables that must be updated at each iteration
`define get_main_quantity qval = V(d, s);

// function call to oor_condition()
`define call_oor_condition oor_condition(qval, Vgs, vds_wc, vgs_wc, b, a_high)

// function call to oor_measure()
`define call_oor_measure qval

// Below are all possible output messages. The format string and variable list are in separate macros.
// (using macros, because string-variables are not recognized as format-strings in $write() statement)

// macro definitions for warning messages (shared)

`define label_fatal   "\n    [SOACHECK_FATAL] "
`define label_tr      "\n    [SOACHECK_TR] "
`define label_info    "\n    [SOACHECK_INFO] "
`define label_dc      "\n    [SOACHECK_DC] "
`define label_dc_end  "\n    [SOACHECK_DC_END] "
`define label_debug   "\n    [SOACHECK_DEBUG] "

`define key_instance      "instance: %m"
`define key_rule          "rule: \"%s\""
`define key_branch        "branch: \"%s\""
`define key_boundary      "boundary: \"[%.5g, %.5g]\""
`define key_boundary_on   "boundary_on: \"[%.5g, %.5g]\""
`define key_boundary_off  "boundary_off: \"[%.5g, %.5g]\""
`define key_device        "device: \"%s\""
`define key_exit_value    "exit value: %.5g"
`define key_exit_time     "exit time: %.15g"
`define key_entry_value   "entry value: %.5g"
`define key_entry_time    "entry time: %.15g"
`define key_param         "parameter: \"%s\""
`define key_peak_value    "peak value: %.5g"
`define key_peak_time     "peak time: %.15g"
`define key_value         "value: %.5g"
`define key_duration      "duration: %.3g"
`define key_duration_perc "duration percentage: %.3g%%"
`define key_suppr_msg     "suppressed messages: %d"
`define key_severity      "severity: \"%s\""
`define key_oversh_perc   "overshoot percentage: %.3g%%"
`define key_message       "message: \"%s\""

// Debug message (printed when debug=1)
`define msg_debug \
    `label_debug, \
    `key_instance, ", ", \
    `key_device, device, "\n"

// physical constants
`define kbol 1.3806226e-23
`define qele 1.6021918e-19

// Message at first violation, when causing simulation to abort (only when stop==1)
`define msg_fatal \
    `label_fatal, \
    `key_instance, ", ", \
    `key_device, device, ", ", \
    `key_branch, branch1, ", ", \
    `key_exit_value, exit_value, ", ", \
    `key_message, msg, "\n"

// Message during transient, when returning to SOA
`define msg_tr \
    `label_tr, \
    `key_instance, ", ", \
    `key_branch, branch1, ", ", \
    `key_exit_value, exit_value, ", ", \
    `key_exit_time, exit_time, ", ", \
    `key_entry_value, entry_value, ", ", \
    `key_entry_time, entry_time, ", ", \
    `key_peak_value, this_peak_val, ", ", \
    `key_peak_time, this_peak_time, ", ", \
    `key_duration, dur, ", ", \
    `key_message, msg, "\n"

// Summary message (when within SOA at end of transient)
`define msg_info \
    `label_info, \
    `key_instance, ", ", \
    `key_device, device, ", ", \
    `key_branch, branch1, ", ", \
    `key_peak_value, tot_peak_val, ", ", \
    `key_peak_time, tot_peak_time, ", ", \
    `key_duration, dur_tot, ", ", \
    `key_duration_perc, 100 * frac, ", ", \
    `key_suppr_msg, num_suppressed_msg, ", ", \
    `key_severity, severity, ", ", \
    `key_message, msg, "\n"

// Summary message, with severity removed
`define msg_info_no_severity \
    `label_info, \
    `key_instance, ", ", \
    `key_device, device, ", ", \
    `key_branch, branch1, ", ", \
    `key_peak_value, tot_peak_val, ", ", \
    `key_peak_time, tot_peak_time, ", ", \
    `key_duration, dur_tot, ", ", \
    `key_duration_perc, 100 * frac, ", ", \
    `key_suppr_msg, num_suppressed_msg, ", ", \
    `key_message, msg, "\n"

// Message when leaving SOA during dc analysis
`define msg_dc_exit \
    `label_dc, \
    `key_instance, ", ", \
    `key_branch, branch1, ", ", \
    `key_exit_value, exit_value, ", ", \
    `key_message, msg, "\n"

// Message when returning to SOA during dc analysis
`define msg_dc_entry \
    `label_dc, \
    `key_instance, ", ", \
    `key_branch, branch1, ", ", \
    `key_exit_value, exit_value, ", ", \
    `key_entry_value, qval, ", ", \
    `key_peak_value, tot_peak_val, ", ", \
    `key_message, msg, "\n"

// Summary message at end of dc analysis
`define msg_dc_end \
    `label_dc_end, \
    `key_instance, ", ", \
    `key_branch, branch1, ", ", \
    `key_value, qval, ", ", \
    `key_exit_value, exit_value, ", ", \
    `key_peak_value, tot_peak_val, ", ", \
    `key_message, msg, "\n"


(* instrument_module *)
module ovcheckva_ldmos_hci_tddb(d, g, s);
    input d, g, s;
    electrical d, g, s;

    // Mandatory model parameters
    parameter integer level        = 1;     // General parameter for all simkit devices (not used)
    parameter integer paramchk     = 0;     // General parameter for all simkit devices used for level of clip warnings
    (* type="instance" *)
    parameter string  device       = "";    // Name of the device (or device model)
    parameter real    tmin         = 0.0;   // Minimal time outside of SOA before a warning is issued
    parameter real    tdelay       = 0.0;   // Time after start of transient that checking is activated
    parameter real    tmaxfrac     =-2.0;   // Maximum acceptable fraction of time outside of SOA
    parameter integer vballmsg     = 1;     // 0: only END/INFO messages; 1: TR message if peak is higher than before; 2: all TR messages
    parameter integer stop         = 0;     // Stop simulation on SOA violation when STOP==1
    parameter integer soadebug     = 0;     // If set to 1, print debug-message @initial_step

    parameter string  message1     = "HCI-TDDB risk; use Life Time Estimator for accurate assessment.";    // Optional informational message to be used in SOA messages

    // check-specific model parameters
    parameter string  branch1    = "V(d,s)";  // Name of the branch to be used in SOA messages
    parameter real    vds_wc     = 0.0;       // worst-case Vds [V], function of W and temp
    parameter real    vgs_wc     = 0.0;       // Vgs [V] at which worst-case Vds reached
    parameter real    a_high     = 0.0;       // slope [V/V] at large negative Vgs (strong inversion)
    parameter real    b          = 0.0;       // characteristic Vgs [V]
    (* type="instance" *)
    parameter real   dummy      = 0.0;        // Need one instance parameter to make all others model parameter

    // definition of out-of-range condition
    analog function integer oor_condition;
        input qval, Vgs, vds_wc, vgs_wc, vgs_char, slope;
        real qval, Vgs, vds_wc, vgs_wc, vgs_char, slope;
        real lin1, exp1, Vds_max;
        begin
            oor_condition = 0;
            if ((Vgs < `Vgs_lim) && (Vgs > -`Vgs_lim)) begin
                // no check for large negative Vgs
                lin1 = slope * (Vgs - vgs_wc) + vds_wc;
                exp1 = slope * vgs_char * (exp((Vgs - vgs_wc) / vgs_char) - 1);
                Vds_max = lin1 - exp1;
                oor_condition = qval < Vds_max;
            end
        end
    endfunction

    // mandatory variables
    integer          outofrange, num_suppressed_msg;
    real             start_time, exit_time, entry_time, exit_value, entry_value, dur, total_time;
    real             this_peak_diff, tot_peak_diff, this_peak_time, tot_peak_time, dur_oor;
    real             qval, this_peak_val, tot_peak_val, oor_meas;
    real             t_now;
    real             dur_tot, frac;
    string           msg, severity;

    // check-specific variables (if any)
    real             Vgs;

    analog begin
        @(initial_step) begin
            msg = message1;
            if (soadebug == 1) begin
                $write(`msg_debug);
            end
        end

        @(initial_step("tran")) begin
            outofrange = 0;
            tot_peak_diff = 0;
            start_time = $abstime; // needed for situation when tran-analysis does not start at t=0.
            t_now = start_time;
            dur_oor = 0.0;
        end

        @(initial_step("dc")) begin
            outofrange = 0;
            tot_peak_diff = 0;
        end

        // get present values
        t_now = $abstime;
        `get_main_quantity
        Vgs = V(g, s);

        if (`do_monitor && ((t_now >= (start_time + tdelay)) || analysis("dc"))) begin
            case (outofrange)
                0 : begin // signal currently in range
                    if (`call_oor_condition == 1) begin // going out-of-range
                        outofrange = 1;  // set status to out-of-range
                        // exit_value exactly matches limit, unless at first time step
                        exit_time = t_now;
                        exit_value = qval;
                        oor_meas = `call_oor_measure;

                        // update peak value and time
                        this_peak_val = qval;
                        this_peak_diff = oor_meas;
                        this_peak_time = t_now;
                        if (analysis("dc")) begin
                            if (stop >= 1) begin
                                $write(`msg_fatal);
                                $fatal(0, "\nFATAL: Simulation is terminated (STOP == 1).");
                            end
                            if (vballmsg >= 1) begin
                                $write(`msg_dc_exit);
                            end
                        end
                    end
                end
                1 : begin // signal currently out of range
                    oor_meas = `call_oor_measure;
                    if (oor_meas > this_peak_diff) begin // update peak value and time
                        this_peak_val = qval;
                        this_peak_diff = oor_meas;
                        this_peak_time = t_now;
                    end
                    if (`call_oor_condition == 0) begin // getting back in range
                        outofrange = 0;
                        entry_time = t_now;
                        entry_value = qval;
                        dur = entry_time - exit_time;
                        if (dur > tmin) begin
                            if (stop >= 1) begin
                                $write(`msg_fatal);
                                $fatal(0, "\nFATAL: Simulation will be terminated (STOP == 1).");
                            end
                            if ((vballmsg >= 2) || ((vballmsg == 1) && (this_peak_diff > tot_peak_diff))) begin
                                $write(`msg_tr);
                            end else begin
                                num_suppressed_msg = num_suppressed_msg + 1;
                            end
                        end
                        dur_oor = dur_oor + dur; // event adds to total, even if shorter than tmin
                        if (this_peak_diff > tot_peak_diff) begin // update over-all peak value and time
                            tot_peak_val = this_peak_val;
                            tot_peak_diff = this_peak_diff;
                            tot_peak_time = this_peak_time;
                        end
                        if (analysis("dc")) begin
                            if (vballmsg >= 1) begin
                                $write(`msg_dc_entry);
                            end
                        end
                    end
                end
                default : ;// should never get here
            endcase // case (outofrange)
        end else begin  // (if $abstime >= tdelay)
            // keep track of status, even when not monitoring
            outofrange = `call_oor_condition;
            exit_time = t_now;
            exit_value = qval;
        end

        // Summaries at end of analysis
        @(final_step("tran")) begin
            total_time = t_now - start_time - tdelay;
            if (`do_monitor && ((dur_oor > 0.0) || (outofrange != 0))) begin
                if (outofrange == 1) begin
                    // handle ongoing violation
                    entry_time = t_now;
                    entry_value = qval;
                    dur = entry_time - exit_time;
                    if ((vballmsg >= 1) && (dur > tmin)) begin
                        $write(`msg_tr);
                    end
                    // update totals
                    dur_oor = dur_oor + dur;
                    if (this_peak_diff > tot_peak_diff) begin
                        tot_peak_val = this_peak_val;
                        tot_peak_time = this_peak_time;
                    end
                end
                dur_tot = dur_oor;
                frac = dur_tot / total_time;
                if (tmaxfrac < 0.0) begin
                    severity = "review";
                end else begin
                    if (frac < tmaxfrac) begin
                        severity = "low";
                    end else begin
                        severity = "high";
                    end
                end
                if (tmaxfrac >= -1.5) begin
                    $write(`msg_info);
                end else begin
                    $write(`msg_info_no_severity);
                end
            end // if do_monitor
        end // final_step tran
        @(final_step("dc")) begin
            if (`do_monitor && (this_peak_diff > tot_peak_diff)) begin // update over-all peak value
                tot_peak_val = this_peak_val;
            end
            if (`do_monitor && ((tot_peak_diff > 0.0) || (outofrange != 0))) begin
                $write(`msg_dc_end);
            end
        end // final_step dc
    end // analog
endmodule // ovcheckva
