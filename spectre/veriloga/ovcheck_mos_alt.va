//***********************************************************************************
//*  NXP SOA-check monitor                                                          *
//***********************************************************************************
//
// Filename:           ovcheck_mos2.va
// Version:            2.0.0
// Date:               2023-10-12
// Author(s):          Gert-Jan Smit
// Source:
//   - git repository: soacheck_va
//   - git commit:     a45af823d1b2a19b1631fd56bc44762b8c70ac8a
//
// Description:
// This module provides (USP-compatible) monitor that checks for overvoltage on all
// six branches of a symmetric MOS device.It features:
// - determination of on/off state based on Vth parameter in OP-output
// - proper handling of source/drain interchange
// - different max voltage in on-state and off-state for selected branches (as agreed
//   with the reliability team).
//
// Note that NO time-interpolation is done (which is different from recent SiMKit
// ovcheck implementations). The reason is that time-interpolation is much more
// complex here, due to the L-shaped SOA-boundary; doing time-interpolation would
// also imply that value-interpolation is needed for Vds and Vgs, increasing the
// complexity even further.
//
// Known limitations:
// - This code requires mica version 16.1 or higher.
//
//***********************************************************************************

`include "disciplines.h"

// out-of-range condition
`define oor_condition(i) ((vmonitor[i] < vlow[i]) || (vmonitor[i] > vhigh[i]))

// out-of-range measure
`define oor_measure(i) abs(vmonitor[i])

// branch names (N.B. string-valued arrays are not possible in verilog-A)
`define branch_name(i) ((i == 1) ? "V(d,s)" : \
                        (i == 2) ? "V(g,s)" : \
                        (i == 3) ? "V(g,d)" : \
                        (i == 4) ? "V(g,b)" : \
                        (i == 5) ? "V(b,s)" : "V(b,d)")
`define msg(i) ((i == 1) ? msg1 : \
                (i == 2) ? msg2 : \
                (i == 3) ? msg3 : \
                (i == 4) ? msg4 : \
                (i == 5) ? msg5 : msg6)


// Below are all possible output messages. The format string and variable list are in separate macros.
// (using macros, because string-variables are not recognized as format-strings in $write() statement)

// macro definitions for warning messages (shared)

`define label_fatal   "\n    [SOACHECK_FATAL] "
`define label_tr      "\n    [SOACHECK_TR] "
`define label_info    "\n    [SOACHECK_INFO] "
`define label_dc      "\n    [SOACHECK_DC] "
`define label_dc_end  "\n    [SOACHECK_DC_END] "
`define label_debug   "\n    [SOACHECK_DEBUG] "

`define key_instance      "instance: %m"
`define key_rule          "rule: \"%s\""
`define key_branch        "branch: \"%s\""
`define key_boundary      "boundary: \"[%.5g, %.5g]\""
`define key_boundary_on   "boundary_on: \"[%.5g, %.5g]\""
`define key_boundary_off  "boundary_off: \"[%.5g, %.5g]\""
`define key_device        "device: \"%s\""
`define key_exit_value    "exit value: %.5g"
`define key_exit_time     "exit time: %.15g"
`define key_entry_value   "entry value: %.5g"
`define key_entry_time    "entry time: %.15g"
`define key_param         "parameter: \"%s\""
`define key_peak_value    "peak value: %.5g"
`define key_peak_time     "peak time: %.15g"
`define key_value         "value: %.5g"
`define key_duration      "duration: %.3g"
`define key_duration_perc "duration percentage: %.3g%%"
`define key_suppr_msg     "suppressed messages: %d"
`define key_severity      "severity: \"%s\""
`define key_oversh_perc   "overshoot percentage: %.3g%%"
`define key_message       "message: \"%s\""

// Debug message (printed when debug=1)
`define msg_debug \
    `label_debug, \
    `key_instance, ", ", \
    `key_device, device, "\n"

// physical constants
`define kbol 1.3806226e-23
`define qele 1.6021918e-19

// Message at first violation, when causing simulation to abort (only when stop==1)
`define msg_fatal \
    `label_fatal, \
    `key_instance, ", ", \
    `key_device, device, ", ", \
    `key_rule, rule, ", ", \
    `key_branch, branch_name, ", ", \
    `key_boundary_on, vlow_on[i], vhigh_on[i], ", ", \
    `key_boundary_off, vlow_off[i], vhigh_off[i], ", ", \
    `key_exit_value, exit_value[i], ", ", \
    `key_message, message, "\n"

// Message during transient, when returning to SOA
`define msg_tr \
    `label_tr, \
    `key_instance, ", ", \
    `key_rule, rule, ", ", \
    `key_branch, branch_name, ", ", \
    `key_boundary_on, vlow_on[i], vhigh_on[i], ", ", \
    `key_boundary_off, vlow_off[i], vhigh_off[i], ", ", \
    `key_exit_value, exit_value[i], ", ", \
    `key_exit_time, exit_time[i], ", ", \
    `key_entry_value, entry_value, ", ", \
    `key_entry_time, entry_time, ", ", \
    `key_peak_value, this_peak_val[i], ", ", \
    `key_peak_time, this_peak_time[i], ", ", \
    `key_duration, dur, ", ", \
    `key_message, message, "\n"

// Summary message (when within SOA at end of transient)
`define msg_info \
    `label_info, \
    `key_instance, ", ", \
    `key_device, device, ", ", \
    `key_rule, rule, ", ", \
    `key_branch, branch_name, ", ", \
    `key_boundary_on, vlow_on[i], vhigh_on[i], ", ", \
    `key_boundary_off, vlow_off[i], vhigh_off[i], ", ", \
    `key_peak_value, tot_peak_val[i], ", ", \
    `key_peak_time, tot_peak_time[i], ", ", \
    `key_duration, dur_tot, ", ", \
    `key_duration_perc, 100 * frac, ", ", \
    `key_suppr_msg, num_suppressed_msg[i], ", ", \
    `key_severity, severity, ", ", \
    `key_message, message, "\n"

// Summary message, with severity removed
`define msg_info_no_severity \
    `label_info, \
    `key_instance, ", ", \
    `key_device, device, ", ", \
    `key_rule, rule, ", ", \
    `key_branch, branch_name, ", ", \
    `key_boundary_on, vlow_on[i], vhigh_on[i], ", ", \
    `key_boundary_off, vlow_off[i], vhigh_off[i], ", ", \
    `key_peak_value, tot_peak_val[i], ", ", \
    `key_peak_time, tot_peak_time[i], ", ", \
    `key_duration, dur_tot, ", ", \
    `key_duration_perc, 100 * frac, ", ", \
    `key_suppr_msg, num_suppressed_msg[i], ", ", \
    `key_message, message, "\n"

// Message when leaving SOA during dc analysis
`define msg_dc_exit \
    `label_dc, \
    `key_instance, ", ", \
    `key_rule, rule, ", ", \
    `key_branch, branch_name, ", ", \
    `key_boundary_on, vlow_on[i], vhigh_on[i], ", ", \
    `key_boundary_off, vlow_off[i], vhigh_off[i], ", ", \
    `key_exit_value, exit_value[i], ", ", \
    `key_message, message, "\n"

// Message when returning to SOA during dc analysis
`define msg_dc_entry \
    `label_dc, \
    `key_instance, ", ", \
    `key_rule, rule, ", ", \
    `key_branch, branch_name, ", ", \
    `key_boundary_on, vlow_on[i], vhigh_on[i], ", ", \
    `key_boundary_off, vlow_off[i], vhigh_off[i], ", ", \
    `key_exit_value, exit_value[i], ", ", \
    `key_entry_value, entry_value, ", ", \
    `key_peak_value, this_peak_val[i], ", ", \
    `key_message, message, "\n"

// Summary message at end of dc analysis
`define msg_dc_end \
    `label_dc_end, \
    `key_instance, ", ", \
    `key_rule, rule, ", ", \
    `key_branch, branch_name, ", ", \
    `key_boundary_on, vlow_on[i], vhigh_on[i], ", ", \
    `key_boundary_off, vlow_off[i], vhigh_off[i], ", ", \
    `key_value, vmonitor[i], ", ", \
    `key_exit_value, exit_value[i], ", ", \
    `key_peak_value, tot_peak_val[i], ", ", \
    `key_message, message, "\n"


(* instrument_module *)
module ovcheckva_mos2(d, g, s, b);
    input d, g, s, b;
    electrical d, g, s, b;

    // Mandatory model parameters
    parameter integer level        = 1;     // General parameter for all simkit devices (not used)
    parameter integer paramchk     = 0;     // General parameter for all simkit devices used for level of clip warnings
    (* type="instance" *)
    parameter string  device       = "";    // Name of the device (or device model)
    parameter real    tmin         = 0.0;   // Minimal time outside of SOA before a warning is issued
    parameter real    tdelay       = 0.0;   // Time after start of transient that checking is activated
    parameter real    tmaxfrac     =-2.0;   // Maximum acceptable fraction of time outside of SOA
    parameter integer vballmsg     = 1;     // 0: only END/INFO messages; 1: TR message if peak is higher than before; 2: all TR messages
    parameter integer stop         = 0;     // Stop simulation on SOA violation when STOP==1
    parameter integer soadebug     = 0;     // If set to 1, print debug-message @initial_step

    // check-specific model parameters
    (* type="instance" *)
    parameter integer  type        = 1;     // 1 = nmos, -1 = pmos
    parameter string   message_vds = "";    // Optional informational message to be used in SOA messages
    parameter string   message_vgs = "";    // Optional informational message to be used in SOA messages
    parameter string   message_vgd = "";    // Optional informational message to be used in SOA messages
    parameter string   message_vgb = "";    // Optional informational message to be used in SOA messages
    parameter string   message_vsb = "";    // Optional informational message to be used in SOA messages
    parameter string   message_vdb = "";    // Optional informational message to be used in SOA messages

    // limits
    parameter real     vhigh_ds_on   = 0.0;
    parameter real     vhigh_ds_off  = 0.0;
    parameter real     vhigh_gc      = 0.0;
    parameter real     vlow_gc       = 0.0;
    parameter real     vhigh_gb_on   = 0.0;
    parameter real     vlow_gb_on    = 0.0;
    parameter real     vfwd_jun_on   = 0.0;
    parameter real     vrev_jun_on   = 0.0;
    parameter real     vfwd_jun_off  = 0.0;
    parameter real     vrev_jun_off  = 0.0;

    parameter real     vgt         = 0.0;   // Gate overdrive at which we consider device to be "on"
    parameter integer  pmosvthsign = 1;     // 1 = pmos has positive Vth, -1 = pmos has negative Vth
    (* type="instance" *)
    parameter string   inst2probe  = "fet"; // Instance name (within same subcircuit of monitor) of device to be checked
    parameter string   param       = "vth"; // name of OP-output parameter to be monitored

    // mandatory variables
    real     entry_time, entry_value, dur, total_time, oor_meas;
    real     start_time, t_now;
    real     dur_tot, frac;

    // MOS-specific
    real     type_i, pmosvthsign_i, vth_sign_correction, test_simprobe;
    real     vth, Vds_i, Vgs_i;
    string   rule, branch_name;
    string   msg1, msg2, msg3, msg4, msg5, msg6, message, severity;
    integer  i, onstate, oor_condition;

    // for each branch separately
    real     vmonitor[1:6], vlow[1:6], vhigh[1:6];
    real     vlow_on[1:6], vlow_off[1:6], vhigh_on[1:6], vhigh_off[1:6];
    real     exit_time[1:6], exit_value[1:6];
    real     this_peak_val[1:6], this_peak_time[1:6], this_peak_diff[1:6];
    real     tot_peak_val[1:6], tot_peak_time[1:6], tot_peak_diff[1:6];
    real     dur_oor[1:6];
    integer  do_monitor[1:6], outofrange[1:6], num_suppressed_msg[1:6];

    analog begin

        @(initial_step) begin
            msg1 = message_vds;
            msg2 = message_vgs;
            msg3 = message_vgd;
            msg4 = message_vgb;
            msg5 = message_vsb;
            msg6 = message_vdb;
            rule = "MOS monitor";
            if (soadebug == 1) begin
                $write(`msg_debug);
            end

            for (i = 1; i <= 6; i = i + 1) begin  // loop over all branches
                outofrange[i] = 0;
                num_suppressed_msg[i] = 0;
                tot_peak_diff[i] = 0.0;
            end // for-loop
            type_i = (type >= 0) ? 1.0 : -1.0;
            pmosvthsign_i = (pmosvthsign >= 0) ? 1.0 : -1.0;
            vth_sign_correction = 1.0;
            if (type_i < 0) begin
                vth_sign_correction = pmosvthsign_i;
            end

            test_simprobe = $simprobe(inst2probe, param, 1e9);
            if (test_simprobe < 1e8) begin
                // determine if branch will be monitored or not
                do_monitor[1] = (vhigh_ds_on > 0.0) && (vhigh_ds_off > 0.0); // Vds
                do_monitor[2] = (vhigh_gc > 0.0) && (vlow_gc < 0.0);         // Vgs
                do_monitor[3] = do_monitor[2];                               // Vgd
                do_monitor[4] = (vhigh_gb_on > 0.0) && (vlow_gb_on < 0.0) && do_monitor[2]; // Vgb
                do_monitor[5] = (vfwd_jun_on > 0.0) && (vfwd_jun_off > 0.0) &&
                                (vrev_jun_on < 0.0) && (vrev_jun_off < 0.0); // Vsb
                do_monitor[6] = do_monitor[5]; // Vdb
            end else begin
                for (i = 1; i <= 6; i = i + 1) begin
                    do_monitor[i] = 0;
                end
                $write("\n    [SOACHECK_WARNING] instance: %m, message: \"device (%s) or parameter (%s) not found, skipping monitoring\"\n", device, param);
            end

            // internal variables, all 24 limits in terms of the input parameters
            vlow_on[1]    = -vhigh_ds_on;
            vhigh_on[1]   = vhigh_ds_on;
            vlow_off[1]   = -vhigh_ds_off;
            vhigh_off[1]  = vhigh_ds_off;

            vlow_on[2]    = type >= 0 ? vlow_gc      : -vhigh_gc;
            vhigh_on[2]   = type >= 0 ? vhigh_gc     : -vlow_gc;
            vlow_off[2]   = type >= 0 ? vlow_gc      : -vhigh_gc;
            vhigh_off[2]  = type >= 0 ? vhigh_gc     : -vlow_gc;

            vlow_on[3]    = type >= 0 ? vlow_gc      : -vhigh_gc;
            vhigh_on[3]   = type >= 0 ? vhigh_gc     : -vlow_gc;
            vlow_off[3]   = type >= 0 ? vlow_gc      : -vhigh_gc;
            vhigh_off[3]  = type >= 0 ? vhigh_gc     : -vlow_gc;

            vlow_on[4]    = type >= 0 ? vlow_gb_on   : -vhigh_gb_on;
            vhigh_on[4]   = type >= 0 ? vhigh_gb_on  : -vlow_gb_on;
            vlow_off[4]   = type >= 0 ? vlow_gc      : -vhigh_gc;
            vhigh_off[4]  = type >= 0 ? vhigh_gc     : -vlow_gc;

            vlow_on[5]    = type >= 0 ? vrev_jun_on  : -vfwd_jun_on;
            vhigh_on[5]   = type >= 0 ? vfwd_jun_on  : -vrev_jun_on;
            vlow_off[5]   = type >= 0 ? vrev_jun_off : -vfwd_jun_off;
            vhigh_off[5]  = type >= 0 ? vfwd_jun_off : -vrev_jun_off;

            vlow_on[6]    = type >= 0 ? vrev_jun_on  : -vfwd_jun_on;
            vhigh_on[6]   = type >= 0 ? vfwd_jun_on  : -vrev_jun_on;
            vlow_off[6]   = type >= 0 ? vrev_jun_off : -vfwd_jun_off;
            vhigh_off[6]  = type >= 0 ? vfwd_jun_off : -vrev_jun_off;
        end

        @(initial_step("tran")) begin
            start_time = $abstime; // needed when tran-analysis does not start at t=0.
            for (i = 1; i <= 6; i = i + 1) begin  // loop over all branches
                dur_oor[i] = 0.0;
            end // for-loop
        end

        // voltages to monitor
        vmonitor[1] = V(d,s);
        vmonitor[2] = V(g,s);
        vmonitor[3] = V(g,d);
        vmonitor[4] = V(g,b);
        vmonitor[5] = V(b,s);
        vmonitor[6] = V(b,d);

        // determine state (on or off)
        Vds_i = type_i * V(d,s);
        Vgs_i = type_i * V(g,s);
        if (Vds_i < 0) begin
            Vgs_i = Vgs_i - Vds_i;
        end
        vth = $simprobe(inst2probe, param, 0.0); // get Vth from MOS device
        vth = vth_sign_correction * vth; // $simprobe() can't be used directly in an expression (in spectre), result will always be 0!!
        onstate = (Vgs_i > (vth + vgt));

        // set limits for each branch based on known state
        for (i = 1; i <= 6; i = i + 1) begin  // loop over all branches
            vlow[i]  = onstate ? vlow_on[i]  : vlow_off[i];
            vhigh[i] = onstate ? vhigh_on[i] : vhigh_off[i];
        end

        t_now = $abstime;

        // start actual monitoring
        if ((t_now >= (start_time + tdelay)) || analysis("dc")) begin
            for (i = 1; i <= 6; i = i + 1) begin  // loop over all branches
                if (do_monitor[i]) begin
                    oor_condition = `oor_condition(i);
                    branch_name = `branch_name(i);
                    message = `msg(i);
                    case (outofrange[i])
                        0 : begin // signal currently in range
                            if (oor_condition == 1) begin // going out-of-range
                                outofrange[i] = 1;  // set status to out-of-range
                                exit_time[i] = t_now;
                                exit_value[i] = vmonitor[i];

                                // update peak value and time
                                this_peak_val[i] = vmonitor[i];
                                this_peak_diff[i] = `oor_measure(i);
                                this_peak_time[i] = t_now;
                                if (analysis("dc")) begin
                                    if (stop >= 1) begin
                                        $write(`msg_fatal);
                                        $fatal(0, "\nFATAL: Simulation is terminated (STOP == 1).");
                                    end
                                    if (vballmsg >= 1) begin
                                        $write(`msg_dc_exit);
                                    end
                                end
                            end
                        end
                        1 : begin // signal currently out of range
                            oor_meas = `oor_measure(i);
                            if (oor_meas > this_peak_diff[i]) begin // update peak value and time
                                this_peak_val[i] = vmonitor[i];
                                this_peak_diff[i] = oor_meas;
                                this_peak_time[i] = t_now;
                            end
                            if (oor_condition == 0) begin // getting back in range
                                outofrange[i] = 0;
                                entry_time = t_now;
                                entry_value = vmonitor[i];
                                dur = entry_time - exit_time[i];
                                if (dur > tmin) begin
                                    if (stop >= 1) begin
                                        $write(`msg_fatal);
                                        $fatal(0, "\nFATAL: Simulation will be terminated (STOP == 1).");
                                    end
                                    if ((vballmsg >= 2) || ((vballmsg == 1) && (this_peak_diff[i] > tot_peak_diff[i]))) begin
                                        $write(`msg_tr);
                                    end else begin
                                        num_suppressed_msg[i] = num_suppressed_msg[i] + 1;
                                    end
                                end
                                dur_oor[i] = dur_oor[i] + dur; // event adds to total, even if shorter than tmin
                                if (this_peak_diff[i] > tot_peak_diff[i]) begin // update over-all peak value and time
                                    tot_peak_val[i] = this_peak_val[i];
                                    tot_peak_diff[i] = this_peak_diff[i];
                                    tot_peak_time[i] = this_peak_time[i];
                                end
                                if (analysis("dc")) begin
                                    if (vballmsg >= 1) begin
                                        $write(`msg_dc_entry);
                                    end
                                end
                            end
                        end
                        default : ;// should never get here
                    endcase // case (outofrange)
                end // if do_monitor
            end // for-loop
        end else begin // if t>tdelay
            // keep track of status, even when not (yet) monitoring
            for (i = 1; i <= 6; i = i + 1) begin  // loop over all branches
                outofrange[i] = `oor_condition(i);
                exit_time[i] = t_now;
                exit_value[i] = vmonitor[i];
            end
        end

        // Summaries at end of analysis
        @(final_step("tran")) begin
            total_time = t_now - start_time - tdelay;
            for (i = 1; i <= 6; i = i + 1) begin  // loop over all branches
                branch_name = `branch_name(i);
                message = `msg(i);
                if (do_monitor[i] && ((dur_oor[i] > 0.0) || (outofrange[i] != 0))) begin
                    if (outofrange[i] == 1) begin
                        // handle ongoing violation
                        entry_time = t_now;
                        entry_value = vmonitor[i];
                        dur = entry_time - exit_time[i];
                        if ((vballmsg >= 1) && (dur > tmin)) begin
                            $write(`msg_tr);
                        end
                        // update totals
                        dur_oor[i] = dur_oor[i] + dur;
                        if (this_peak_diff[i] > tot_peak_diff[i]) begin
                            tot_peak_val[i] = this_peak_val[i];
                            tot_peak_time[i] = this_peak_time[i];
                        end
                    end
                    dur_tot = dur_oor[i];
                    frac = dur_tot / total_time;
                    if (tmaxfrac < 0.0) begin
                        severity = "review";
                    end else begin
                        if (frac < tmaxfrac) begin
                            severity = "low";
                        end else begin
                            severity = "high";
                        end
                    end
                    if (tmaxfrac >= -1.5) begin
                        $write(`msg_info);
                    end else begin
                        $write(`msg_info_no_severity);
                    end
                end // if do_monitor
            end // for-loop
        end // final_step tran

        @(final_step("dc")) begin
            for (i = 1; i <= 6; i = i + 1) begin  // loop over all branches
                branch_name = `branch_name(i);
                message = `msg(i);
                if (do_monitor[i] && (this_peak_diff[i] > tot_peak_diff[i])) begin // update over-all peak value
                    tot_peak_val[i] = this_peak_val[i];
                end
                if (do_monitor[i] && ((tot_peak_diff[i] > 0.0) || (outofrange[i] != 0))) begin
                    $write(`msg_dc_end);
                end
            end // for-loop
        end // final_step dc

    end // analog
endmodule // ovcheckva
